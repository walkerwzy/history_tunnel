<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Fixed Test</title>
    <style>
        body { margin: 0; background: black; color: white; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #threejs-canvas { display: block; width: 100%; height: 100%; }
        #status { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="threejs-canvas"></canvas>
        <div id="status">Initializing...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, tunnel, events;
        const status = document.getElementById('status');

        function init() {
            try {
                status.textContent = 'Setting up Three.js...';

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threejs-canvas') });
                renderer.setSize(window.innerWidth, window.innerHeight);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                status.textContent = 'Creating tunnel...';
                createTunnel();

                status.textContent = 'Creating events...';
                createEvents();

                status.textContent = 'Starting animation...';
                animate();

                status.textContent = '✅ Timeline ready! Scroll to travel through time.';

            } catch (error) {
                status.innerHTML = `❌ Error: ${error.message}`;
                console.error('Error:', error);
            }
        }

        function createTunnel() {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(50, 20, -100),
                new THREE.Vector3(-50, -20, -200),
                new THREE.Vector3(0, 0, -300)
            ]);

            const geometry = new THREE.TubeGeometry(curve, 50, 30, 8, false);
            const material = new THREE.MeshBasicMaterial({
                color: 0x001122,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            tunnel = new THREE.Mesh(geometry, material);
            scene.add(tunnel);
        }

        function createEvents() {
            events = new THREE.Group();

            // Create test events
            const testEvents = [
                { name: 'Test Event 1', year: 0, region: 'European', importance: 8, category: '政治' },
                { name: 'Test Event 2', year: -100, region: 'Chinese', importance: 7, category: '文化' },
                { name: 'Test Event 3', year: -200, region: 'European', importance: 9, category: '军事' }
            ];

            testEvents.forEach(event => {
                const geometry = new THREE.SphereGeometry(event.importance / 3, 8, 8);

                let color = 0xffffff;
                switch (event.category) {
                    case '军事': color = 0xff6b6b; break;
                    case '政治': color = 0x4ecdc4; break;
                    case '文化': color = 0xffe66d; break;
                    case '经济': color = 0xa8e6cf; break;
                }

                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.userData = event;

                // Position based on year and region
                const yearPosition = -Math.abs(event.year) * 2;
                const regionOffset = event.region === 'European' ? -20 : 20;
                sphere.position.set(regionOffset, 0, yearPosition);

                events.add(sphere);
            });

            scene.add(events);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotate tunnel
            if (tunnel) {
                tunnel.rotation.z += 0.005;
            }

            // Pulse events
            if (events) {
                events.children.forEach((event, index) => {
                    const scale = 1 + Math.sin(Date.now() * 0.002 + index) * 0.2;
                    event.scale.setScalar(scale);
                });
            }

            renderer.render(scene, camera);
        }

        // Mouse wheel handler
        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            camera.position.z = Math.max(-300, Math.min(0, camera.position.z + event.deltaY * 0.1));
        });

        // Start
        init();
    </script>
</body>
</html>